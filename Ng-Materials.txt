					Angular
..............................................................................................
                                           DOM 
				 (Document Object Model)


DOM: 
   DOM is spec , defined by W3C to reprenent html elements inside javascript engine.



HTML;
  HTML is programming language -  dsl pl /declarative pl.


HTML internal work flow:
........................

index.html -source code

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>
//////////////////////////////////////////////////////////////////////////////////////////////

Birth of Javascript:
...................

At Netscap decided to modifiy the linked list / tree via special program 

netscap decided to create very light weight programming language to access the tree and modify the tree at runtime - js

/////////////////////////////////////////////////////////////////////////////////////////////


HTML Elements types

1.built in elements

2.custom elements
HTML Elements types

1.built in elements

2.custom elements



1.built in elements
  are part of html language spec
 h1,body,p,nav,div

compiler design

 source code
                              compiler db -[div]
                                 |
  <div></div> ----- compile----compiler
                                  |
                      ------------------------
                    if present             
                      |
                    execution
                      |
                     node
                       |
                     screen


                                compiler db -[Subramanian]
                                    |
  <subramanian></subramaian> ----- compile----compiler
                                  |
                      ------------------------
                    if present            if not present           
                      |                        |
                    execution              throw error - UnKnown Element
                      |                                 |
                     node                              Convert that element into PlanText   
                       |                               |
                     screen                           render



2.IN 2007-2008 W3C Decided to introduce new html spec - html 5

 -custom elements - how to add new elements
 -custom attributes - how to add custom attribues on existing html specs

Custom Types
int,float =  class A{ int,float }

how to teach browser to understand custom elements and attributes
   -via Javascript


                             compiler db -[Subramanian]
                                    |
 <subramanian></subramaian> ----- compile----compiler
                                  |
                      ------------------------
                    if present            if not present           
                      |                        |
                    execution              feed into js 
                      |                                 |
                     node                              js will do something   
                       |                               |
                     screen                           render



eg:

class AppDrawer extends HTMLElement {...}

window.customElements.define('app-drawer', AppDrawer);

// Or use an anonymous class if you don't want a named constructor in current scope.
window.customElements.define('app-drawer', class extends HTMLElement {...});



  			              compiler db -[div,Subramanian]
                                           |
<subramanian></subramaian> --jsengine will add new defintion--- compile----compiler
                                   |
                      ------------------------
                    if present            if not present           
                      |                        |
                    execution              throw error - UnKnown Element
                      |                                 |
                     node                              Convert that element into PlanText   
                       |                               |
                     screen                           render

////////////////////////////////////////////////////////////////////////////////////////////
Angular and Custom Elements:

 Angular follows custom element spec in order to create apps.


  Custom Element
  <app-root></app-root>
                  |
                  ------------->|import { Component } from '@angular/core';

				@Component({
 				 selector: 'app-root',
  				templateUrl: './app.component.html',
  				styleUrls: ['./app.component.css']
				})
				export class AppComponent {
					  title = 'ng-helloworld';
				}


<app-root></app-root> ---------------function AppComponent(){ 
                                           //dom code
                                     }


/////////////////////////////////////////////////////////////////////////////////////////////
					Angular Project setup
.............................................................................................

Angular cli :

npm install -g @angular/cli


ng new getting-started

cd getting-started

ng serve
.............................................................................................

Angular infra objects

1.module
2.component
3.service
4.directive
5.pipes

Note : 
  in ng we never create infra object using new keyword
ng depedency injector will create object , we use it.


Modules:

1.es6 modules -  to share code
  export , import

2.angular modules
   logical modules to group objects


main.ts -  main file/program

import { enableProdMode } from '@angular/core';
 |            |            |         |
keyword   function       keyword 

@angular -folder name - look node_modules
core  -subfolder

enableProdMode()

import { environment } from './environments/environment';


import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

to initalize the platform features-(browser features)

			

platformBrowserDynamic().bootstrapModule(AppModule).catch(err => console.error(err));

To initalize the appModule



What is appModule?

 -Object, holding the whole angular apps 
 -Container Object , container objects
 -Every angular must have only one AppModule object.

app.module.ts -  container object file

Objects are created by angular, but object template(classes) we need to provide.


class ClssName{}

...........................................................................................
					Angular Decorators
............................................................................................
Built in decorators
 Component 
 ContentChild 
 ContentChildren
 Directive Host 
 HostBinding
 HostListener
 Inject 
 Injectable 
 Input
 NgModule
 Optional 
 Output 
 Pipe
 Self
 SkipSelf 
 ViewChild 
 ViewChildren


@NgModule -  to create module object - container objects

we have two types of modules

1.main module /app module

2.sub module


how to create  module object?

@NgModule({})
export class AppModule {  }


new AppModule() - we dont need to create this.
.............................................................................................
					Angular MVC Architecture
.............................................................................................

M - model - domain objects
V - View - dom elements -  html elements
C- Controller - Component

Component:

 Object to represent "View" in app

Every angular app must have one Component - Root Component -Main Compoent -Main Page-App Component. - Landing Page


How to create Component?

Component consist of following things?

1.template
    collection of angular instructions

Angular instructions:
1.1. html elements - div,p,span
1.2. data binding symbols -special instructions
     *,[],(),#,directives <>,pipes(|)

2.css
   style sheet
3.code
   logic written in typescript 
 variables,methods,interfaces



How to create Component?

Component consist of following things?

1.template
    collection of angular instructions

Angular instructions:
1.1. html elements - div,p,span
1.2. data binding symbols -special instructions
     *,[],(),#,directives <>,pipes(|)

2.css
   style sheet
3.code
   logic written in typescript 
 variables,methods,interfaces

Comonent has follwing things?

 -dependency
     -services

Steps:

1.declare component class and export it.

export class AppComponent {

}

2.decorate component class. -@Component
Decorator that marks a class as an Angular component and provides configuration metadata that determines how the component should be processed, instantiated, and used at runtime.

3.meta Object {}
@Component({})

@Component({})
export class AppComponent {

}

4.provide meta information
 selector - custom element name
 template - instructions
 css - styles for component



Types of templates:

1.inline template
   template is part of component itself , provided within string
  template: `
           <div>
             <h1>HR Block Angular Apps welcomes you</h1>
           </div>
  `
2.external template
   template is outside component and provided via a separate .html file
templateUrl: './app.component.html',

import { Component } from "@angular/core";

@Component({
  selector: 'app-root',
  templateUrl:'./app.component.html'
})
export class AppComponent {

}
//////////////////////////////////////////////////////////////////////////////////////////////
				   Dependency Injection
............................................................................................

Angular Creates objects automatically , we dont need to create them.

How angular understand that , object need to be created. 

Thats where configuration comes into picture.


//AppModule - to have other objects
// contains injector configuration to create object

import { NgModule } from "@angular/core";
import { BrowserModule } from "@angular/platform-browser";
import { AppComponent } from "./app.component";



@NgModule({
  declarations: [AppComponent], //view objects - Component,Directive,Pipes
  imports: [BrowserModule], //submodules -from angular or custom sub modules
  providers: [], // services,
  bootstrap: [AppComponent]
})
export class AppModule { }
...................................&&&&&&&&&&&&&&&&&&&........................................
				Component driven architecture
............................................................................................

 Angular apps are collection of components.
 Component represent "custom html element"
 custom html element may compose other custom element and htmls elements- hi
 you need to design app based on html hierachical design

  <parent>         ----------------------------Appcomponent -selector
      <child-1>  ------------------------------Child1Component
              <sub-child></sub-child>
      </child-1>
      <child-2> -sibling
		<sub-child>
			...
		</sub-child>
      <child-2>
  </parent>


 <div>
    <div>
        <div></div>
    </div>
 <div>

 <app-root>
  <app-header>
        ....
   </app-header>

  <app-body>
        ....
  </app-body>

  <app-footer>

 </app-footer>
 </app-root>


Task : 
 -create header /body /footer compont
 
Angular coding best pratices:
...............................
https://angular.io/guide/styleguide


file name:
 header.component.ts
 headercomponent.ts
 hcmp.ts

component:
 ts file
 html file
 css file
 spec file

header.component.ts
header.component.html
header.component.css
header.component.spec.ts

style guide for file names

domainname.component|service|directive|pipe.ts
hero.component.ts
hero.service.ts
hero.directive.ts
hero.pipe.ts


Custom elements Naming convention:Component selectors

 <app-root> - recommended
  
 <approot>  - not recommended.

Do use dashed-case or kebab-case for naming the element selectors of components.

............................................................................................

class Names:

 1.Noun
 2.should be meaningfull
 3.should have suffix component,service,directive,pipe

 HeaderComponent
 HeaderService
 HeaderDirective
 HeaderPipe
..............................................................................................
Steps to create Component

1.declare componenent class
2.declare component html 
3.write component logic
4.dependency injection inside moudle
5.refer the compoent inside template.
...........................................................................................

Style guide to create components or any objects

1.modularazation

-physical modularity 
   folders
     files

src
  app
   |
   header
     header files
   footer
     footer files
   body 
    body files

-logical modularity 
    object grouping
 sub modules
   header module 


Steps:

1.create folder
2.create modules
3.create components/directives/services 
4.DI inside sub module


Error: src/app/app.component.html:2:5 - error NG8001: 'app-header' is not a known element:
1. If 'app-header' is an Angular component, then verify that it is part of this module.
2. If 'app-header' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.

2     <app-header></app-header>
      ~~~~~~~~~~~~


Module Scope:
Any Component,Pipe,Directive,submodule refers inside a module will be available inside that module only. Module Scope


Module Scope:

1.public scope
   if any objects belong to all modules that  is public
2.private scope
  if any objects belong to that module is private including appmodule.

if you want to make any object in public scope, you need to configer it

"exports: "
..............................................................................................
                       Angular CLI   Automate && accelerate your work flow
.............................................................................................

Problems in the dev flow:

Tasks:

1.create folder
2.create files - component-ts,html,css,spec
3.create module
4.declare class -cmp,service...
5.refer the classes inside module
6.you need to inject submodule into main module..

if you repeate the same thing for every object , which increases lot of time.

Automation:
 code generation automation

angular cli tool to generate code.

Generates and/or modifies files based on a schematic.

ng generate <schematic> [options]
ng g <schematic> [options]


//create folder, create module, inject this module into app module
>>ng g m footer --module=app
CREATE src/app/footer/footer.module.ts (192 bytes)
UPDATE src/app/app.module.ts (451 bytes)

create component, inside footer folder, inject into footer module, make it available public
i dont want css file,i want html file,i dontwant spec file

ng g c footer/footer  --flat=true --export=true --inline-style=true --skip-tests=true   --module=footer


 --flat=true :  create any thing inside exsiting folder
 --export=true : make it public
 --inline-style=true : i dont want css file
 --skip-tests=true  :dont create spec files
 --module=header  : inject inside header module

ng g m body --module=app   
ng g c body/body  --flat=true --export=true --inline-style=true --skip-tests=true   --module=body
...............................................................................................				Data binding
..............................................................................................

UI types

1.static ui
   only html
2.dynamic ui
  html + data and which change by user interactions

Data binding:
 Transfering state to ui(view)

Types of databinding

1.interpolation
2.property binding
3.attribute binding
4.event binding
5.two way data binding
6.class binding
7.style binding

...........................................................................................

export type Address = {
    city: string;
}

<h2>
    Primitive Data
</h2>
<p>String {{firstName}} {{lastName}}</p>
<p>Number {{salary}}</p>
<p>Boolean {{status}}</p>
<h2>
    Object
</h2>
<p>Object {{address.city}}</p>

<h2>
    Arrays
</h2>
<!-- iteration  -->
<ul>
    <li *ngFor="let skill of skills">
        <span>{{skill}}</span>
    </li>
</ul>


import { Component, OnInit } from '@angular/core';
import { Address } from '../types/address.type';

@Component({
  selector: 'app-interpolation',
  templateUrl: './interpolation.component.html',
  styles: [
  ]
})
export class InterpolationComponent implements OnInit {

  //state /models/data
  firstName: string = "Subramanian"
  lastName: string = "Murugan";
  salary: number = 1000;
  status: boolean = true

  //object
  address: Address = {
    city: 'Coimbatore'
  }
  //arrays
  skills: Array<string> = ["Java", "Angular", "Cloud", "Devops"]

  constructor() { }

  ngOnInit(): void {
  }

}
..........................................................................................
			[] -  symbol used for property,attribute,style,class binding
...........................................................................................

What is   attribute and property? - []

<img src="imagelocation"/>
      |
attribute

Why [] ?

  To bind value dynamically.
  
<img src="logo.png"/> -static image

<img [src]="variable"> - dynamic image

<div hidden> --- static value to hide div element

<div [hidden]="booleanvariable"> --- static value to hide div element

<button enabled>

<button [enabled="booleanvariable"> - dynamic value

if you use "[]"  on html elements which is called "attribute binding"
............................................................................................
if you use [] on class or style attribute

 <div class="tab"> - static css binding

 </div>

 <div [class]="cssClass"> - dynamic binding
    -class binding

 <div style="color:red"> - static css binding
 <div [style]="conditionstyle"> dynamic css 
    -style binding
 
............................................................................................

can i use [] on custom elements

yes
<app-header [title]="value/variable"> - passing title dynamically
<app-product [products]="products">

if you use "[]"  on custom elements which is called "property binding"
............................................................................................

Angular Dev tool:https://angular.io/guide/devtools
..................
-dynamic interaction
-to know the tree model of compoent.

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-attributebinding',
  templateUrl: './attributebinding.component.html',
  styles: [
  ]
})
export class AttributebindingComponent implements OnInit {

  imageLocation: string = "favicon.ico"
  isEnabled:boolean = false;
  hide:boolean =true;

  constructor() { }

  ngOnInit(): void {
  }

}

attributebinding.component.html
<img src="favicon.ico"/>
<img [src]="imageLocation" />
<button [disabled]="isEnabled">Download</button>
<div [hidden]="hide">Show /hide</div>
.............................................................................................
			     Property binding
...........................................................................................

Passing data from parent component to child component.
we can pass data upto n of childrens
Which is called "uni directional data flow model"
Components can be communicated via props binding.

Two steps:

How to pass data from the parent to child?

1.From the parent component : passing data
  
  <app-greeter [message]="message">

 message:string="hello"

2. How to receive the data
   
   @Input() decorator
   message:string=""
................

  import { Component, OnInit } from '@angular/core';
  import { Address } from '../types/address.type';

  @Component({
    selector: 'app-parent',
    templateUrl: './parent.component.html',
    styles: [
    ]
  })
  export class ParentComponent implements OnInit {
    mymessage: string = "Hello! Property"
    address:Address = {
      city:'Coimbatore'
    }
    skills:Array<string> = ["java","javascript","Angular"]
    // address!: Address
    constructor() { }

    ngOnInit(): void {
    }

  }

parent.component.html
<h2>This is parent</h2>
<app-child [message]="mymessage" 
[address]="address" [skills]="skills">

</app-child>
  
............

import { Component, Input, OnInit } from '@angular/core';
import { Address } from '../types/address.type';

@Component({
  selector: 'app-child',
  templateUrl: './child.component.html',
  styles: [
  ]
})
export class ChildComponent implements OnInit {

  @Input()
  message: string = "";

  /**
   * ts config 
   * strict: true 
   * means that variable must have been initalized
   * but i dont want to make strict : false
   * there is solution : definite assigment operator "!"
   */
  @Input()
  address!: Address;

  @Input('skills')
  myskills!:Array<string>;

  constructor() { }

  ngOnInit(): void {
  }

}

child.component.html

<h2>Data from Parent</h2>
<h3>String {{message}}</h3>
<h3>Object {{address?.city ?? "Default city"}}</h3>
<h3>Array</h3>
<ul>
    <li *ngFor="let skill of myskills">
        <span>{{skill}}</span>
    </li>
</ul>

App component:
 <div>
    <h1>Property Binding</h1>
    <app-parent></app-parent>
  </div>
.............................................................................................
					CSS - how to use css 

Angular attaches css to component 

1.global css
 -styles.css
 -bootstrap framework

2.component sepcific css
..............................................................................................
				.......................................................................................
					Event Binding
.............................................................................................


EventTarget Object: Event
  It connects dom object and listner method.
  where listener method can read values and other proproperties of dom object.

btn.addEventListener = function(evt){
  evt.target   

}
$event  - is global variable from the angular which has reference of EventTarget object


Two way binding:

-data is transfered from view to controller and controller to view 

How to implement two way data binding

1.events

///////////////////////////////////////////////////////////////////////////////////////////

Simple events:
<div>
    <button class="btn btn-success" (click)="onClick()" >Click</button>
    <!-- Pass data to listener -->
    <hr>
    <button class="btn btn-success" (click)="onReceive('hello how are you?')" >SendData</button>
</div>
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-event',
  templateUrl: './event.component.html',
  styles: [
  ]
})
export class EventComponent implements OnInit {


  //listener function
  onClick() {
    alert('hello')
  }
  onReceive(message:string) {
    alert(message)
  }

  constructor() { }

  ngOnInit(): void {
  }

}
..........................................................................................
			How to read input from the keyboards
                           (Two way data binding)						
............................................................................................


import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { EventComponent } from './event.component';
import { InputComponent } from './input.component';
import { FormsModule } from '@angular/forms';



@NgModule({
  declarations: [
    EventComponent,
    InputComponent
  ],
  imports: [
    CommonModule,FormsModule
  ],
  exports: [
    EventComponent,
    InputComponent
  ]
})
export class EventbindingModule { }



import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-input',
  templateUrl: './input.component.html',
  styles: [
  ]
})
export class InputComponent implements OnInit {

  text:string = ""
  messageOne:string = ""
  messageTwo:string ="defaultvalue"
  messageThree:string = ""
  readInput(ctrl: any) {
    this.text = ctrl.target.value 
  }

  constructor() { }

  ngOnInit(): void {
  }

}

input.component.html

<div>
    <h2>Input Event</h2>
    <div>
        <h3>With Listener</h3>
        <h3>{{text}}</h3>
        <input (input)="readInput($event)">
    </div>

    <div>
        <h3>Without Listener</h3>
        <h3>{{messageOne}}</h3>
        <input (input)="messageOne=$event.target.value">
    </div>
    <div>
        <h3>Property Binding + Event Binding </h3>
        <h3>{{messageTwo}}</h3>
        <input  [value]="messageTwo" (input)="messageTwo=$event.target.value">
    </div>
    <div>
        <h3>Property Binding + Event Binding = Banana Box Notation [()] </h3>
        <h3>{{messageThree}}</h3>
        <input [(ngModel)]="messageThree">
    </div>
</div>
.............................................................................................
				Custom Events -Component Communication
..............................................................................................

Types of events:

1.dom events - click,input,keypress.......
2.custom events - events for custom elements

Why custom events?

Component communcation:

1.parent to child - via props pattern
2.child to parent - via custom events
3.across components -  via services

2.child to parent - via custom events


Steps : write two components

1.parent
2.child

2.child to parent - via custom events



Steps : write two components

1.parent
2.child


Parent

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html',
  styles: [
  ]
})
export class ParentComponent implements OnInit {

  constructor() { }

  ngOnInit(): void {
  }

}

2.Child Component

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-child',
  templateUrl: './child.component.html',
  styles: [
  ]
})
export class ChildComponent implements OnInit {

  constructor() { }

  ngOnInit(): void {
  }

}

Step 2:

 EventEmitter:

Use in components with the @Output directive to emit custom events synchronously or asynchronously, and register handlers for those events by subscribing to an instance.

1.EventEmitter is used to broad cast values to Parent Components

class EventEmitter<T> extends Subject {
  constructor(isAsync?: boolean): EventEmitter<T>
  emit(value?: T): void
  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription
}

2.EventEmitter object is Subclass Rxjs Subject.

create EventEmitter Object of type in child compoent.

eventemitter is used to send custom events.

   onSendRequest = new EventEmitter<string>();

3.We have to decorate eventemitter with @Output()

  @Output()
  onSendRequest = new EventEmitter<string>();

4.send data to Parent Component

    <div>
        <input [(ngModel)]="message">
    </div>
    <div>
        <button (click)="onSend()">Send To Parent</button>
    </div>

export class ChildComponent {

  message: string = "Good Value"
  //event emitter Declaration
  @Output()
  onSendRequest = new EventEmitter<string>();
  onSend() {
    alert('sending data to parent')
    //emit data  -  next method in subject
    this.onSendRequest.emit(this.message)
  }

}

5.Listens event and grab the data from the Child

<div>
    <h1 style="text-align: center;">Parent Component</h1>
    <h2>{{childMessage}}</h2>
</div>
<hr/>
<app-child (onSendRequest)="onReadData($event)" ></app-child>


export class ParentComponent {

  childMessage: string;

  onReadData(event: any) {
    this.childMessage = event
  }

}

/////////////

final code :

Child:
<div>
    <h1 style="text-align: center;">Child Component</h1>
    <div>
        <input [(ngModel)]="message">
    </div>
    <div>
        <button (click)="onSend()">Send To Parent</button>
    </div>
</div>


export class ChildComponent implements OnInit {

  message: string = "Good Value"
  //event emitter Declaration
  @Output()
  onSendRequest = new EventEmitter<string>();

  constructor() { }

  ngOnInit(): void {
  }
  onSend() {
    alert('sending data to parent')
    //emit data  -  next method in subject
    this.onSendRequest.emit(this.message)
  }

}


Parent:

<div>
    <h1 style="text-align: center;">Parent Component</h1>
    <h2>{{childMessage}}</h2>
</div>
<hr/>
<app-child (onSendRequest)="onReadData($event)" ></app-child>

export class ParentComponent {

  childMessage: string;
  onReadData(event: any) {
    this.childMessage = event
  }

}
..............................................................................................
				  Dynamic Css  - How to change Style dynamically
.............................................................................................
class binding and style binding
...............................

class binding:

<div [class.special]="isSpecial" [class]="classExpression">Some text.</div>

style binding:

<nav [style.background-color]="expression"></nav>
<nav [style.backgroundColor]="expression"></nav>



<div (click)="changeStyle()" [class.special]="isSpecial">Some text.</div>
<a [style.text-decoration]="activeLinkStyle">Home Page</a>

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-dynamiccss',
  templateUrl: './dynamiccss.component.html',
  styles: [
  ]
})
export class DynamiccssComponent implements OnInit {
  isSpecial: boolean = true
  activeLinkStyle = 'overline';
  constructor() { }

  changeStyle() {
    this.isSpecial = !this.isSpecial
  }

  ngOnInit(): void {
  }

}

styles.css
.special {
   font-size: large;
   font-weight: 400;
   color:brown;
}
..............................................................................................
					..............................................................................................
				 Pipes
..............................................................................................

What is pipe?
 pipe object used for data formating.

eg:
 show uppercase
 show money values - $,#,
 show date format  - 1/10/2021 , feb 10 2021...
 custom formates

Angular provides lot of built in pipes, you can write your own pipes as well.
....
Syntax:
  some data | nameof the pipe.


Builtin pipes:

DatePipe: Formats a date value according to locale rules.

UpperCasePipe: Transforms text to all upper case.

LowerCasePipe: Transforms text to all lower case.

CurrencyPipe: Transforms a number to a currency string, formatted according to locale rules.

DecimalPipe: Transforms a number into a string with a decimal point, formatted according to locale rules.

PercentPipe: Transforms a number to a percentage string, formatted according to locale rules.

asyncPipe : to bind list of values async


<div>
  <h1 style="text-align: center;">Pipes</h1>
  <div>
    <h1>String</h1>
    <p>{{message | uppercase}}</p>
    <p>{{message | lowercase}}</p>
    <p>{{message | titlecase}}</p>
    <h1>Numbers</h1>
    <p>{{price | percent}}</p>
    <p>{{price | currency}}</p>
    <!-- pipe with input -->
    <p>{{price | currency:'INR'}}</p>
    <h1>Date</h1>
     <p>{{date | date}}</p>
     <p>{{date | date:'short'}}</p>
     <p>{{date | date:'dd/MM/yyyy'}}</p>

    <!-- Pipe chaining -->
    <p>{{date | date:'medium' | uppercase}}</p>

    <!-- Json -->
    <h1>JSON</h1>

    <p>{{employee | json}}</p>
    <h1>Custom Pipes</h1>
    <p>{{price | decimalfraction}}</p>
    <p>{{price | decimalfraction:3}}</p>
  </div>
</div>

<!-- 10.8766 --- >10.9 / 10.99 -->
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'decimalfraction'
})
export class DecimalfractionPipe implements PipeTransform {

  transform(value: number, numberofDigits: number = 1): string {
    return value.toFixed(numberofDigits)
  }

}

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'pipes';
  message: string = "hello!"
  price: number = 1000.898766
  date = new Date();
  employee = {
    id: 1,
    name: 'subramanian',
    city: 'coimbatore'
  }
}
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { DecimalfractionPipe } from './decimalfraction.pipe';



@NgModule({
  declarations: [
    DecimalfractionPipe
  ],
  imports: [
    CommonModule
  ],
  exports: [
    DecimalfractionPipe
  ]
})
export class UtilsModule { }
............................................................................................
					Directives
...........................................................................................

What is directive?
  Directive is custom element / attribute..

<app-root> ,<app-root [title]>


Types of Directives:
1.Template directive
2.Structural directive
3.Attribute directive




1.Template directive
   The directive with Template ; all components create template directive
  <app-root> ----------------template directive
  <app-profile>--------------template directive

All component's meta data is inherited from Directive meta.
Directive is parent , Component is child

Every component is directive.


2.Structural Directive
   It is type of directive, used to change HTML Layouts.
   They shape or reshape the DOM's "Structure" typically by adding,removing and manipulating
   the host elements to which they attached.
   
  -Host element means html elements eg div,span,li,table.
  -It is one of the "special attribute" directive
  -All structural directive starts with "*" notation.

Built in structural directives

1.*ngFor : for loop
2.*ngIf  : if condition
3.*ngSwitch : switch

..............................................................................................						    CommonModule

Where are structural directives?

ngFor itself is object part of commonmodule.

incase if you are using structural directives inside submodule, commonModule must have been injected.

if any component part of main module, we dont need to inject commonModule becuase BrowserModule which contains all structural directives.





List /Array rendering:
......................

Layouts:
1.List view Layout
   -ul li
2.Card View Layout
  div
3.Grid View Layout
  table tr td


1.for Loop: *ngFor

-where ever you want to repeate elements

element could be dom element or custom elements

eg:
 <anyelement *ngFor="condition">

 <div *ngFor="let variableName of arrayname">
       {{VariableName.property}}
 </div>
 This code will create more div elements

 <app-item-list *ngFor="">
Static view:
<ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>

    </ul>

<div>
    <h1 style="text-align: center;">For loop</h1>

    <!--ul element-->
    <ul>
        <li *ngFor="let i of numbers">{{i}}</li>
    </ul>
    <!--Ui element for tod-->
    <ul class="list-group">
        <li class="list-group-item d-flex justify-content-between align-items-center" *ngFor="let todo of todos">
            <span class="badge badge-primary badge-pill"> {{todo.id}} </span> {{todo.title}}
        </li>

    </ul>
    <div class="card" *ngFor="let todo of todos">
        <h5 class="card-header">{{todo.id}}</h5>
        <div class="card-body">
            <h5 class="card-title">{{todo.userId}}</h5>
            <p class="card-text">{{todo.title}}</p>
            <a href="#" class="btn btn-primary">Update</a>
        </div>
    </div>
</div>

////////////////////////////////////////////////////////////////////////////////////////////

eg:
<div>
    <ul>
        <li *ngFor="let course of courses">
            {{course}}
        </li>
    </ul>
</div>
<h2>Users data</h2>
<div>
    <div *ngFor="let user of users">
        <h3>{{user.username}}</h3>
        <p>{{user.email}}</p>
        <address>
            <p>{{user.address.street}},{{user.address.city}}</p>
        </address>
    </div>
</div>

import { Component, OnInit } from '@angular/core';
import { USERS } from '../mock-data/users';

@Component({
  selector: 'app-forloop',
  templateUrl: './forloop.component.html',
  styles: [
  ]
})
export class ForloopComponent implements OnInit {

  courses: Array<string> = ["javascript", "angular", "Microservices"]

  users: Array<any> = USERS;




  constructor() { }

  ngOnInit(): void {
  }

}
.............................................................................................
				if..else,ngtemplate,#
............................................................................................

import { Component, OnInit } from '@angular/core';
import { USERS } from '../mock-data/users';

@Component({
  selector: 'app-ifelse',
  templateUrl: './ifelse.component.html',
  styles: [
  ]
})
export class IfelseComponent implements OnInit {

  isEnabled: boolean = true
  users!: Array<any>;
  loading: boolean = true;
  status: string = "loading....."
  isHidden: boolean = false;

  constructor() {
    setTimeout(() => {
      this.users = USERS;
      this.loading = !this.loading;
    }, 5000);
  }

  toggle() {
    this.isHidden = !this.isHidden;
  }
  ngOnInit(): void {
  }

}
<div *ngIf="isEnabled; else mycondition">
    <h1>You have Facility!</h1>
</div>

<ng-template #mycondition>
    <h1>Sorry! Facility is not available</h1>
</ng-template>

<h2>Progress bar</h2>
<div *ngIf="loading; else notLoading  ">
    <h2>{{status}}</h2>
</div>
<ng-template #notLoading>
    <div *ngFor="let user of users">
        <h3>{{user.username}}</h3>
        <p>{{user.email}}</p>
        <address>
            <p>{{user.address.street}},{{user.address.city}}</p>
        </address>
    </div>
</ng-template>
<h2>Ng vs Hidden attribute</h2>
<button class="btn btn-success" (click)="toggle()">Toggle</button>
<!--Show and Hide-->
<!-- <div *ngIf="isHidden">
    <h1>Hello</h1>
</div> -->
<div [hidden]="isHidden">
    <h1>Hai</h1>
</div>
..............................................................................................
					Switch case
..............................................................................................

<h1 style="text-align: center;">Swich case </h1>
<input [(ngModel)]="input">
<button (click)="showFeedback()">Show Feedback</button>

<div [ngSwitch]="feedback">
    <p *ngSwitchCase="'good'">Good</p>
    <p *ngSwitchCase="'verygood'">Very Good</p>
    <p *ngSwitchCase="'bad'">Bad</p>
    <p *ngSwitchDefault>Your input is not matching</p>
</div>

<div [ngSwitch]="feedback">
    <ng-template [ngSwitchCase]="'good'">
        <h3>Good</h3>
    </ng-template>
    <ng-template [ngSwitchCase]="'verygood'">
        <h3>Very Good</h3>
    </ng-template>
    <ng-template [ngSwitchCase]="'bad'">
        <h3>bad</h3>
    </ng-template>
    <ng-template ngSwitchDefault>
        <h3>Your input is not matching</h3>
    </ng-template>
</div>
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-switchcase',
  templateUrl: './switchcase.component.html',
  styles: [
  ]
})
export class SwitchcaseComponent implements OnInit {

  input: string = ""
  feedback: string = "good"
  constructor() { }
  showFeedback() {
    this.feedback = this.input
  }

  ngOnInit(): void {
  }

}
..............................................................................................
				   Attribute Directives
.............................................................................................

How to add new extra attributes on html elements

<div myattribute=somevalue>

 Adding extra behaviour to existing dom elements.

eg:
 <div subu="">

 <div appHighlight>

How to create our own attribute directive.

import { Directive, ElementRef, HostListener } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {

  constructor(private element:ElementRef) { 
    //  console.dir(this.element.nativeElement)
    this.element.nativeElement.style.backgroundColor = 'yellow'
  }
  @HostListener('mouseenter')
  onMouseEnter() {
    this.highLight('blue')
  }
  @HostListener('mouseleave')
  onMouseLeave() {
    this.highLight(null)
  }
  private highLight(color: any) {
    this.element.nativeElement.style.backgroundColor = color
  }
}
<div>
    <h1 appHighlight>IBM</h1>

    <p appHighlight>IBM</p>

</div>
.............................................................................................
				    Services
			    Async Programming - promises,Rxjs
.............................................................................................
..............................................................................................
				  Services
.............................................................................................
Service is object going to hold biz logic and data.

In Mvc , service is acting as bridge between UI and back end


 View --------------Controller---------Service-----backend

 View-----------------Component---------Service-----Backend.


Types of services 

1.global/shared  services:
  Services are used by many components.
eg: Logger,Utility
2.Domain specfic services
  users
    usercomponent
    usersservice


////////////////////////////////////////////////////////////////////////////////////////

Declare Service,Create Service Object,grab service OBject(di)

import { Injectable } from "@angular/core";


//@Injectable tells to create object

@Injectable()
export class GreeterService {
    constructor() {

    }
    public sayHello(): string {
        return `Hello`;
    }
}
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { GreeterComponent } from './greeter.component';
import { GreeterService } from './greeter.service';



@NgModule({
  declarations: [
    GreeterComponent
  ],
  imports: [
    CommonModule
  ],
  exports: [
    GreeterComponent
  ],
  providers: [GreeterService]
})
export class GreeterModule { }

import { Component, OnInit } from '@angular/core';
import { GreeterService } from './greeter.service';

@Component({
  selector: 'app-greeter',
  templateUrl: './greeter.component.html',
  styles: [
  ]
})
export class GreeterComponent implements OnInit {

  message!: string;

  constructor(private greeterService:GreeterService) {
    this.message = this.greeterService.sayHello();
  }

  ngOnInit(): void {
  }

}
..........................................................................................
			Injector information inline rather than using providers
..............................................................................................

import { Injectable } from "@angular/core";

/**
 * To create service object we have different types of injector
 * -Component Injector
 * -Module Injector 
 * -Global Injector  - Recommended to create instance one time(singleton),reuse any where in the applicatoin
 */

//@Injectable tells to create object

@Injectable({
    providedIn: 'root'
})
export class GreeterService {
    constructor() { }
    
    public sayHello(): string {
        return `Hello`;
    }
}
...............................................................................................
					Data initalization inside compoent
..............................................................................................


way to initalize the data:

1.inside constructor.

 message!: string;

  constructor(private greeterService:GreeterService) {
    this.message = this.greeterService.sayHello();
  }

but it is not recommended. constructors only used for di not for data initalization.

Component Life cycle apis
...........................

Component Life Cycle Methods: hooks:
   methods are called by angular runtime when component/directive goes in transistion.

init and destory hook:
......................

init - called after constructor completes, where you can write resource insentive tasks
  like api calls,timers,websocket integration.

destory -called once if the component is removed from memory or from component tree
   -cleanup activities.

init and destroy is represented inside life cyle hooks interfaces

OnInit interface
 ngOnInit(): void {
    throw new Error('Method not implemented.');
  }
init and destroy is represented inside life cyle hooks interfaces

OnInit interface
 ngOnInit(): void {
    throw new Error('Method not implemented.');
  }


import { Component, OnDestroy, OnInit } from '@angular/core';
import { GreeterService } from './greeter.service';

@Component({
  selector: 'app-greeter',
  templateUrl: './greeter.component.html',
  styles: [
  ],
  // providers:[GreeterService]
})
export class GreeterComponent { // implements OnInit, OnDestroy {

  message!: string;

  constructor(private greeterService: GreeterService) {
    // this.message = this.greeterService.sayHello();
  }

  ngOnInit(): void {
    //initalization code
    this.message = this.greeterService.sayHello();
  }
  ngOnDestroy() {
    //cleanup code will go here
  }

}
.............................................................................................
			 Services can have its own dependencies
.............................................................................................

import { Injectable } from "@angular/core";
import { MessageService } from "../utils/message.service";

/**
 * To create service object we have different types of injector
 * -Component Injector
 * -Module Injector 
 * -Global Injector  - Recommended to create instance one time(singleton),reuse any where in the applicatoin
 */

//@Injectable tells to create object

@Injectable({
    providedIn: 'root'
})
export class GreeterService {
    constructor(private messageService: MessageService) { }

    public sayHello(): string {
        this.messageService.add('SayHello method  is called')
        return `Hello`;
    }
    public sayHai(): string {
        this.messageService.add('SayHai method is called')
        return `Hai`;
    }
}
import { Component, OnDestroy, OnInit } from '@angular/core';
import { MessageService } from '../utils/message.service';
import { GreeterService } from './greeter.service';

@Component({
  selector: 'app-greeter',
  templateUrl: './greeter.component.html',
  styles: [
  ],
  // providers:[GreeterService]
})
export class GreeterComponent { // implements OnInit, OnDestroy {

  message!: string;
  messages: Array<string> = [];

  constructor(private greeterService: GreeterService, private messageService: MessageService) {
    // this.message = this.greeterService.sayHello();
  }

  ngOnInit(): void {
    //initalization code
    this.message = `${this.greeterService.sayHello()} ${this.greeterService.sayHai()}` ;
    this.messages = this.messageService.fetch();
  }
  ngOnDestroy() {
    //cleanup code will go here
  }

}
<div>
    <h2>{{message}}</h2>
    <div *ngFor='let message of messages'> {{message}} </div>

</div>
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class MessageService {
  private messages: string[] = [];

  add(message: string) {
    this.messages.push(message);
  }
  fetch(): string[] {
    return this.messages;
  }

  clear() {
    this.messages = [];
  }
}
.............................................................................................
				 Services with biz logic
.............................................................................................

import { Component, OnInit } from '@angular/core';
import { MessageService } from '../utils/message.service';
import { CalculatorService } from './calculator.service';

@Component({
  selector: 'app-calculator',
  templateUrl: './calculator.component.html',
  styles: [
  ]
})
export class CalculatorComponent implements OnInit {

  result: number = 0;

  constructor(private calcService: CalculatorService, public messageService: MessageService) {
  }
  public add() {
    this.result = this.calcService.add(10, 10);
  }
  public multiply() {
    this.result = this.calcService.multiply(10, 10);
  }
  ngOnInit(): void {
  }

}
............................................................................................
<div>
    <h1>Result {{result}}</h1>
    <button (click)="add()">Add</button>
    <button (click)="multiply()">Multiply</button>

    <div *ngFor='let message of messageService.fetch()'> {{message}} </div>
</div>
.............................................................................................
import { Injectable } from '@angular/core';
import { MessageService } from '../utils/message.service';

@Injectable({
  providedIn: 'root'
})
export class CalculatorService {
  constructor(private messageService: MessageService) { }

  //biz method
  public add(a: number, b: number): number {
    this.messageService.add('add method  is called')
    return a + b;
  }
  public substrac(a: number, b: number): number {
    this.messageService.add('substract method  is called')
    return a - b;
  }
  public multiply(a: number, b: number): number {
    this.messageService.add('multiply method  is called')

    return a * b;
  }
  public div(a: number, b: number): number {
    this.messageService.add('div method  is called')
    return a / b;
  }
}
..............................................................................................
				 Types of services

1.Sync services
  blocking services which blocks the current thread, so that ui will be freezed until the data
or result is available.
 
2.Async services
  Non blocking
  the task which wont block the current thread.
  The computation will be done in other threads, once the task is over the result will be handed over to main thread.

How to implement async programming in js(angular)?

1.callback pattern - core pattern
2.Promise pattern - wrapper for callbacks
3.Reactive programming-rxjs


1.callback pattern - core pattern
async apis
-timer
-ajax
-websocket

import { Injectable } from '@angular/core';
import { USERS } from '../mock-data/users';

@Injectable({
  providedIn: 'root'
})
export class UserService {

  constructor() { }
  //sync service
  // fetchUser() {
  //   return USERS
  // }
  //async service with callback
  fetch(callback: Function) {
    setTimeout(callback, 5000, USERS);
  }

}
..............................................................................................
				    Promises - Simplifying the callbacks
.............................................................................................

import { Component, OnInit } from '@angular/core';
import { User } from '../types/user.type';
import { UserService } from './user.service';

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styles: [
  ]
})
export class UserComponent implements OnInit {

  users!: Array<User>;
  loading: boolean = true;
  status: string = "loading....."

  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.userService.fetch().then(users => {
      this.loading = !this.loading;
      this.users = users;
    });
  }

}
import { Injectable } from '@angular/core';
import { USERS } from '../mock-data/users';
import { User } from '../types/user.type';

@Injectable({
  providedIn: 'root'
})
export class UserService {

  constructor() { }
  //async service with promises
  fetch(): Promise<User[]> {
    return new Promise((resolve, reject) => {
      //async logic
      setTimeout(resolve, 5000, USERS);
    });
  }

}
............................................................................................					Reactive Programming- Rxjs
...........................................................................................

What is reactive programming?

Reactive Programming is programming model with data streams.
An API for asynchronous programming with observable streams

Why Reactive programming?

You are transfering data from one place to another in network.
with in system (microservices) or across system (outside) like ui,mobile

sync or async you can transfer data.

streaming is nothing data transfer does not happen in one go rather which will move chunk by chunk.

Process the stream by appling functions.

Reactive programming = Data Streaming in async way.

Rx programming is based three design pattern

1.Observer
2.Functional Programming
3.Iterator
.............................................................................................
		 Reactive programming is language/framework/lib independant 
...........................................................................................
Java script + Reactive Programming = rxjs

What is rxjs?

rxjs is javascript lib for writing reactive programming in js echo system.

rxjs and angular:

angular uses rxjs for data streaming and processing in async way.

..............................................................................................
				 rxjs core concepts

reactive programming is purly based on "event driven arch".
publisher emits events , subscribers listen for event.


push based programming model where publisher push 
 data,error,complete

Observer design pattern implementation

-Publisher
   who push the data.

Angular : publisher is service

-Subscriber
   listen for the data


Angular : subscribers are components
..............................................................................................

RXJS Core objects:

Publisher:
 Observable
 Subjects

Subscriber
 Subscription
 Subscriber

Operators
 functions used for data processing.

Scheduler
  For concurrency data processing
.............................................................................................
				 Rxjs and angular

Angular has integreted rxjs built in, so we dont need to install separatly.

Angular apis uses rxjs:

1.HTTPClient
2.Routers
3.Forms
4.EventEmitter
etc...


steps:

1.create stream object- observable
2.push data /stream data
3.subscribe data/listening for data.

.............................................................................................

import { Injectable } from '@angular/core';
import { of, Observable, range } from 'rxjs';
import { delay, filter, map, takeLast } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class NumberStreamService {

  constructor() { }
  //streamming
  // public getValue(): Observable<number> {
  //   return new Observable(subscriber => {
  //     //push data into stream
  //     subscriber.next(1);
  //     subscriber.next(2);
  //     subscriber.next(3);
  //     setTimeout(() => {
  //       subscriber.next(4);
  //       subscriber.complete();
  //     }, 1000);
  //   });

  // }
  //creational operator : of
  public getValue(): Observable<number> {
    return of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
  }

  //process the data : transformation and filter

  //double it:

  public doubleIt(): Observable<number> {
    return of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
      .pipe(
        map(i => i * 2),
        map(j => j)
      );
  }

  // public findEvenNumbers(): Observable<number> {
  //   return of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
  //     .pipe(
  //       filter(i => i % 2 === 0)
  //     );
  // }

  //find even numbers for from to 100
  // public findEvenNumbers(): Observable<number> {
  //   return range(1,100)
  //     .pipe(
  //       filter(i => i % 2 === 0)
  //     );
  // }
  //find even numbers from 1 to 100 , but i need last 10 values only
  public findEvenNumbers(): Observable<number> {
    return range(1,100)
      .pipe(
        filter(i => i % 2 === 0),
        delay(5000),
        takeLast(10)
      );
  }


}
import { Component, OnInit } from '@angular/core';
import { NumberStreamService } from './numberstream.service';

@Component({
  selector: 'app-numberreactive',
  templateUrl: './numberreactive.component.html',
  styles: [
  ]
})
export class NumberreactiveComponent implements OnInit {

  stream$: Array<number> = [];
  constructor(private numService: NumberStreamService) { }

  ngOnInit(): void {
    //listener/subscriber
    //simpleStream();
    //this.doubleIt();
    this.findEvenNumbers();
  }
  private simpleStream() {
    this.numService.getValue().subscribe(num => {
      console.log(`stream data  : ${num}`)
      this.stream$.push(num);
    }, err => {
      console.log(err)
    }, () => {
      console.log('done');
    });
  }
  private doubleIt() {
    this.numService.doubleIt().subscribe(num => {
      this.stream$.push(num);
    }, err => {
      console.log(err)
    }, () => {
      console.log('done');
    });
  }

  private findEvenNumbers(){
    this.numService.findEvenNumbers().subscribe(num => {
      this.stream$.push(num);
    }, err => {
      console.log(err)
    }, () => {
      console.log('done');
    });
  }

}
.
<h1>Streaming</h1>
<ul>
    <li *ngFor="let data of stream$">
        <span>{{data}}</span>
    </li>
</ul>
.............................................................................................
				 How to stream array
.............................................................................................
	
import { Injectable } from '@angular/core';
import { from, Observable, of } from 'rxjs';
import { USERS } from '../mock-data/users';
import { User } from '../types/user.type';

@Injectable({
  providedIn: 'root'
})
export class ArraystreamService {

  constructor() { }
  // public findAll(): Observable<User> {
  //   return from(USERS);
  // }
  public findAll(): Observable<User[]> {
    return of(USERS);
  }
}
import { Component, OnInit } from '@angular/core';
import { Observable } from 'rxjs';
import { User } from '../types/user.type';
import { ArraystreamService } from './arraystream.service';

@Component({
  selector: 'app-arrayreactive',
  templateUrl: './arrayreactive.component.html',
  styles: [
  ]
})
export class ArrayreactiveComponent implements OnInit {

  // stream$!: User[];
//  users!: Observable<User[]>;
  constructor(public arrayService: ArraystreamService) { }

  ngOnInit(): void {
    // this.arrayService.findAll().subscribe(data => {
    //   console.log(data);
    //   this.stream$ = data;
    // });
   // this.users = this.arrayService.findAll();
  }

}
<div>
    <ul>
        <!-- <li *ngFor="let user of stream$">
            <!-- <span>{{user.id}} {{user.name}}</span> -->
            <!-- <span>{{user | json}}</span> -->
        <!-- </li> -->
         
        <!-- <li *ngFor="let user of users | async">
            <span>{{user | json}}</span>
        </li> -->
          <li *ngFor="let user of arrayService.findAll() | async">
            <span>{{user | json}}</span>
        </li>
    </ul>
</div>
.............................................................................................
			   Error Handling
............................................................................................


import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { map, catchError } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class ErrorhandlingService {

  constructor() { }

  //handling error inside subscribe method
  // public handleError(): Observable<number> {
  //   return of(1, 2, 3, 4, 5).pipe(
  //     map(n => {
  //       if (n === 4) {
  //         throw 'four!';
  //       }
  //       return n;
  //     }),
  //   )

  // }

  //implementing fallback
  //catchError will convert error into success response
  public handleError(): Observable<number> {
    return of(1, 2, 3, 4, 5).pipe(
      map(n => {
        if (n === 4) {
          throw 'four!';
        }
        return n;
      }),
      catchError(err => {
        return of(this.fallback());
      })
    )
  }
  private fallback() {
    return 900;
  }


}
...

import { Component, OnInit } from '@angular/core';
import { ErrorhandlingService } from './errorhandling.service';

@Component({
  selector: 'app-errorhandling',
  templateUrl: './errorhandling.component.html',
  styles: [
  ]
})
export class ErrorhandlingComponent implements OnInit {

  constructor(private errorHandlingSerivce: ErrorhandlingService) { }

  ngOnInit(): void {
    // this.errorHandlingSerivce.handleError().subscribe(data => {
    //   console.log(data);
    // }, err => {
    //   console.log(err);
    // });
    //without error handler: using catchError

    this.errorHandlingSerivce.handleError().subscribe(data => {
      console.log('data block ', data);
    }, err => {
      console.log('error block',err);
    });
  }


}
..............................................................................................
				 Resilience Operators


1.fail fast
	if api hits error , immediatly you throw an error, catch it or fallback it.
2.retry
  if api hits error , dont throw an error immediately,rather give some time recovery.



import { Injectable } from '@angular/core';
import { Observable, of, timer } from 'rxjs';
import { map, catchError, retry, retryWhen, tap, delayWhen } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class ErrorhandlingService {

  constructor() { }

  //handling error inside subscribe method
  // public handleError(): Observable<number> {
  //   return of(1, 2, 3, 4, 5).pipe(
  //     map(n => {
  //       if (n === 4) {
  //         throw 'four!';
  //       }
  //       return n;
  //     }),
  //   )

  // }

  //implementing fallback
  //catchError will convert error into success response
  public handleError(): Observable<number> {
    return of(1, 2, 3, 4, 5).pipe(
      map(n => {
        console.log('hitting', n);
        if (n === 4) {
          throw 'four!';
        }
        return n;
      }),
      retry(3),
      //       retryWhen(errors =>
      //         errors.pipe(
      //           // log error message
      //           tap(val => console.log(`Value ${val} was too high!`)),
      //           // restart in 5 seconds
      // //delayWhen(val => timer(val * 1000))
      //         )
      //       ),
      catchError(err => {
        return of(this.fallback());
      })
    )
  }
  private fallback() {
    return 900;
  }

}
.............................................................................................
					Communicaitons

Types of communication:
1.unicast 
   one to one 
  one publisher and one subscriber

2.multi cast

  one publisher , many subscribers
..............................................................................................						Multi cast
..............................................................................................

There are two ways to broadcast values 

1.cold stream
2.hot stream


1.cold stream

1.Observable that doesn’t emit items until a subscriber subscribes.

2.If we have more than one subscriber, then observable will 
emit sequence of items to all subscribers one by one.

3.Each subscriber get "fresh copy of the data from the begining".

4.Most of Observerables are Cold.
..............................................................................................
eg:
import { Injectable } from '@angular/core';
import { interval, Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class ColdstreamService {

  constructor() { }

  //cold stream api
  public emitValue(): Observable<number> {
    return interval(1000).pipe(tap(() => console.log('emitting')));
  }
}

<h1>Subscriber-1</h1>
<ul>
    <li *ngFor="let i of values">
        {{i}}
    </li>
</ul>

import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { ColdstreamService } from './coldstream.service';

@Component({
  selector: 'app-cstreamsub1',
  templateUrl: './cstreamsub1.component.html',
  styles: [
  ]
})
export class Cstreamsub1Component implements OnInit {

  values: number[] = [];
  subscription!: Subscription;

  constructor(public coldService: ColdstreamService) { }

  ngOnInit(): void {
    this.subscription = this.coldService.emitValue().subscribe(data => {
      // console.log(data)
      this.values.push(data);
    })
    setTimeout(() => {
      this.subscription.unsubscribe();
      console.log('unsubscribe')
    }, 5000)
  }
  ngOnDestory() {
    console.log('component has been destroyed')
    this.subscription.unsubscribe()
  }
}

<h1>Subscriber-2</h1>
<ul>
    <li *ngFor="let i of values">
        {{i}}
    </li>
</ul>
import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { ColdstreamService } from './coldstream.service';

@Component({
  selector: 'app-cstreamsub2',
  templateUrl: './cstreamsub2.component.html',
  styles: [
  ]
})
export class Cstreamsub2Component implements OnInit {

  values: number[] = [];
  subscription!: Subscription;

  constructor(public coldService: ColdstreamService) { }

  ngOnInit(): void {
    setTimeout(() => {
      this.subscription = this.coldService.emitValue().subscribe(data => {
        console.log(data)
        this.values.push(data);
      })
    }, 10000);
    setTimeout(() => {
      this.subscription.unsubscribe()
    }, 15000)

  }
  ngOnDestory() {
    console.log('component has been destroyed')
    this.subscription.unsubscribe()

  }

}
............................................................................................
				Hot Stream
.............................................................................................

Hot Observable:

1.Observables that don’t wait for any subscription. 
 They start emitting items   when created.

2.They don’t emit the sequence of items again for a new subscriber.

3.When an item is emitted by hot observable, all the subscribers that are   subscribed will get the emitted item at once.


There are many ways to implement hot observables:


converting cold into hot:
.........................

operators to convert cold into hot
  publish
  connect
  share
  multicast
  

1.ConnectableObservable : publish and connect
  publish will start publishing data to multiple subscribers and as soon as connect is called

2.share method
  Can be shared a stream among subscribers  by call
////////////////////////////////////////////////////////////////////////////////////////////

Subjects:
   Used for multi casting ; built in hot Observable
............................................................................................
				
import { Injectable } from '@angular/core';
import { interval, Observable } from 'rxjs';
import { tap, map, share } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class HotstreamService {

  hotStream!: Observable<number>;
  
  constructor() {
    //emit value in 1s
    const source = interval(1000);
    //log side effect, emit result
    const stream = source.pipe(
      tap(() => console.log('***starts***')),
      map(i => i * 2),
      share()
    );
    //make it hot.
    //share observable among subscribers
    this.hotStream = stream.pipe(share());
  }
  public emitValue(): Observable<number> {
      return this.hotStream;
  }


}
<h1>Hot Subscriber-1</h1>
<ul>
    <li *ngFor="let i of values">
        {{i}}
    </li>
</ul>

import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { HotstreamService } from './hotstream.service';

@Component({
  selector: 'app-hotstreamsub1',
  templateUrl: './hotstreamsub1.component.html',
  styles: [
  ]
})
export class Hotstreamsub1Component implements OnInit {
  subscription!: Subscription;
  values: number[] = [];

  constructor(private hotStream:HotstreamService) { }

  ngOnInit(): void {
    this.subscription = this.hotStream.emitValue().subscribe(data => {
      this.values.push(data);
    })
    // setTimeout(() => {
    //   this.subscription.unsubscribe();
    //   console.log('unsubscribe')
    // }, 5000)

  }
  ngOnDestory() {
    console.log('component has been destroyed')
    this.subscription.unsubscribe()
  }

}

<h1>Hot Subscriber-2</h1>
<ul>
    <li *ngFor="let i of values">
        {{i}}
    </li>
</ul>


import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { HotstreamService } from './hotstream.service';

@Component({
  selector: 'app-hotstreamsub2',
  templateUrl: './hotstreamsub2.component.html',
  styles: [
  ]
})
export class Hotstreamsub2Component implements OnInit {

  subscription!: Subscription;
  values: number[] = [];

  constructor(private hotStream:HotstreamService) { }

  ngOnInit(): void {
    setTimeout(() => {
      this.subscription = this.hotStream.emitValue().subscribe(data => {
        console.log(data)
        this.values.push(data);
      })
    }, 10000);
    // setTimeout(() => {
    //   this.subscription.unsubscribe();
    //   console.log('unsubscribe')
    // }, 5000)
  }
  ngOnDestory() {
    console.log('component has been destroyed')
    this.subscription.unsubscribe()
  }

}

///////////////////////////////////////////////////////////////////////////////////////////

                                    Subjects
////////////////////////////////////////////////////////////////////////////////////////////


Subject:

What is a Subject?  :create the hot observable from scratch
  
 In RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers.

While plain Observables are unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are multicast.

"each subscribed Observer owns an independent execution of the Observable"
   =>Every Subscribers has its own independent copy of the Object.
   lets say 10 subscribers, 10 Observable copy is maintained.

"A Subject is a special type of Observable which shares a single execution path among observers"

"You can think of this as a single speaker talking at a microphone in a room full of people. Their message (the subject) is being delivered to many (multicast) people (the observers) at once. This is the basis of multicasting. Typical observables would be comparable to a 1 on 1 conversation".

There are 4 variants of subjects:

1.Subject - No initial value or replay behavior.
2.AsyncSubject - Emits latest value to observers upon completion.
3.BehaviorSubject - Requires an initial value and emits its current value (last emitted item) to new subscribers.
4.ReplaySubject - Emits specified number of last emitted values (a replay) to new subscribers.
...........................................................................................
				BehaviourSubject


import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class SubjectService {

  private behaviour = new BehaviorSubject(1);
  constructor() { }

  public broadCast(): BehaviorSubject<number> {
    return this.behaviour;
  }

}

<h1>Subject 1 {{value}}</h1>
<button (click)="emitValue()">BroadCast To All Component</button>


import { Component, OnInit } from '@angular/core';
import { SubjectService } from './subject.service';

@Component({
  selector: 'app-subjectone',
  templateUrl: './subjectone.component.html',
  styles: [
  ]
})
export class SubjectoneComponent implements OnInit {

  value!: number;
  constructor(private subject: SubjectService) { }

  ngOnInit(): void {
    this.subject.broadCast().subscribe((data) => {
      this.value = data;
    });
  }
  public emitValue() {
    this.subject.broadCast().next(400)
  }

}

<h1> Subject 2 {{value}}</h1>

import { Component, OnInit } from '@angular/core';
import { SubjectService } from './subject.service';

@Component({
  selector: 'app-subjecttwo',
  templateUrl: './subjecttwo.component.html',
  styles: [
  ]
})
export class SubjecttwoComponent implements OnInit {
  value!: number;
  constructor(private subject: SubjectService) { }

  ngOnInit(): void {
    this.subject.broadCast().subscribe((data) => {
      this.value = data;
    });
  }

}
.............................................................................................
				HTTP Communication
............................................................................................

in order to make http calls with rest api servers,js offers an object called "XMLHTTPRequest"

But frameworks provide abstraction over XHR object.

Angular provides XHR Abstraction - @angular/common/http

Angular XHR is powered with Reactive -  XHR + REACTIVE - XHR +Streaming


HTTP MOdule:

common/http :

HttpClientModule :
  This is moudle having all http related apis

This HttpClientModule must be injected before interacting with http end points

HttpClientModule is injected into shared module in general


Steps:
ng g m httpprogramming --module=app


import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';



@NgModule({
  declarations: [],
  imports: [
    CommonModule
  ]
})
export class HttpprogrammingModule { }


............................

Back end setup:
..............
create json server 
start server

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { User } from '../types/user.type';

@Injectable({
  providedIn: 'root'
})
export class UserService {

  constructor(private http: HttpClient) { }

  //service api
  public findAll(): Observable<User[]> {
    const url = 'http://localhost:3000/users';
    return this.http.get<User[]>(url).pipe();
  }

}
import { Component, OnInit } from '@angular/core';
import { User } from '../types/user.type';
import { UserService } from './user.service';

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styles: [
  ]
})
export class UserComponent implements OnInit {

  users!: Array<User>;
  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.userService.findAll().subscribe(users => {
      this.users = users;
    });
  }

}
<div>
    <h1>Users</h1>
    <ul>
        <li *ngFor="let user of users">
            <span>{{user.id}} {{user.name}}</span>
        </li>
    </ul>
</div>
............................................................................................
				 Error handling,resilence,add other api

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { catchError, retry, tap } from 'rxjs/operators';
import { User } from '../types/user.type';
import { environment } from 'src/environments/environment';

@Injectable({
  providedIn: 'root'
})
export class UserService {

  constructor(private http: HttpClient) { }

  //service api
  public findAll(): Observable<User[]> {

    const url = `${environment.url}/users`;
    return this.http.get<User[]>(url).pipe(
      retry(5),
      // catchError(() => of<User[]>([{ id: 0, name: 'foo' }])
      catchError(this.handleError<User[]>('findAll-users', this.fallback()))
    );
  }
  private fallback() {
    return [{ id: 0, name: 'foo' }];
  }

  findById(id: number): Observable<User> {
    const url = `${environment.url}/users/${id}`;
    return this.http.get<User>(url).pipe(
      tap(() => console.log(`fetched user id = ${id}`)),
      catchError(this.handleError<User>(`findByid id=${id}`))
    )
  }
  //generic error handler
  private handleError<T>(operation = "operation", result?: T) {
    return (error: any): Observable<T> => {
      //console.error(error);
      return of(result as T);
    }
  }
}
import { Component, OnInit } from '@angular/core';
import { Observable } from 'rxjs';
import { User } from '../types/user.type';
import { UserService } from './user.service';

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styles: [
  ]
})
export class UserComponent implements OnInit {

  users!: Array<User>;
  user!: Observable<User>;
  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.userService.findAll().subscribe(users => {
      this.users = users;
    });
  }
  showUserByid() {
    this.user = this.userService.findById(13);
  }

}
<div>
    <h1>Users</h1>
    <ul>
        <li *ngFor="let user of users">
            <span>{{user.id}} {{user.name}}</span>
        </li>
    </ul>

</div>
<div>
    <button (click)="showUserByid()">Show User by Id</button>
    <h1>User By Id</h1>
    <h2>{{user  | async | json}}</h2>
</div>

UPDATE,REMOVE,DELETE: SAMPLE code :

save(post: Post) {
        const httpOptions = {
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        }
        return this.http.post<Post>(this.url, post, httpOptions)
            .pipe(tap(() => console.log(`added Post`)),
                catchError(this.handleError<Post>('save Post'))
            )
    }
    remove(id: number): Observable<Post> {
        const httpOptions = {
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        }
        const url = `http://localhost:3000/posts/${id}`;
        return this.http.delete<Post>(url, httpOptions)
            .pipe(tap(() => console.log(`deleted Post ${id}`)),
                catchError(this.handleError<Post>('delete Post'))
            )
    }
    update(id:number,post: Post):Observable<Post> {
        console.log('service update method')
        const url = `http://localhost:3000/posts/${id}`;

        const httpOptions = {
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        }
        return this.http.put<Post>(url, post, httpOptions)
            .pipe(tap(() => console.log(`updated Post ${post.id}`)),
                catchError(this.handleError<any>('update Post'))
            )
    }
.............................................................................................
				 Routing
............................................................................................
What is routing?
 Navigation between pages.

Routing is implemented in web apps via links - hyper links.

HTML 5 offers hyper links through which we can navigate from one page to another page.

HTML offers an address to which we will be redirected- URL,URI.

Types of navigation

1.static  - html
2.dynamic  - via server side programs

In 2008, html 5 introduced dynamic navigation inside browser via javascript api called history which is object contains apis related for navigation.
  This is brith of single page web apps.

single page web apps(spa) contains one physical page we call landing page - home page

How to create single page Application?

SPAs use AJAX and HTML5 to create fluid and responsive Web apps, without constant page reloads. However, this means much of the work happens on the client side, in JavaScript.

SPA Stack:

javascript
HTML 5
CSS 3

Frameworks and SPA :

 Every client side js frameworks today offers spa implementation.
 Angular provides a spa implemenation via "@angualr/routing" project.

Routing Core Concepts:

1.URL Patterns

http://www.mydomain.com/index.html - static url
http://www.mydomain.com/contactus.pdf -static url
http://www.mydomain.com/login.aspx / login.jsp /login.php  - dynamic content url

http://www.mydomain.com/api/users/comments  -  Resource based url - REST API


Spa url patterns: hashbang url pattern

http://www.mydomain.com/index.html#contactus
http://www.mydomain.com/index.html#products
http://www.mydomain.com/index.html#profiles

spa simple syntax : here landing page and # symbol not req.which is implict.
http://www.mydomain.com/profiles

2.URLs AND page

 Every url is mapped with Component which display content of page.

///////////////////////////////////////////////////////////////////////////////////////////


Steps:

1.routermodule

2.main menu

3.component creation and link

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home.component';

//mapping component with url
const routes: Routes = [
  {
    path: 'home', component: HomeComponent
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

<h1 style="text-align: center;">Routing Application</h1>
<hr>
<nav>
    <a routerLink="/home">Home</a>
</nav>
<hr>
<!-- Place Holder -->
<router-outlet></router-outlet>

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styles: [
  ]
})
export class HomeComponent implements OnInit {

  constructor() { }

  ngOnInit(): void {
  }

}
<p>home works!</p>
..............................................................................................
			 Page Not Found,Named Path
..............................................................................................
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home.component';
import { PageNotFoundComponent } from './page-not-found.component';

//mapping component with url
const routes: Routes = [
  {
    //index path - /
    path: '', redirectTo: '/home', pathMatch: 'full'
  },
  {
    //named path
    path: 'home', component: HomeComponent
  },
  //page not found
  {
    path:'**' ,component:PageNotFoundComponent
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
.............................................................................................
				 Dynamic urls
..............................................................................................

/users/:id  -  /users/1

  {
    path: 'greeting/:message', component: MessageComponent
  },

http://localhost:4200/greeting/hello

Objects:
RouterModule,RouterOutlet,RouterLink

How to read route information inside component?

 //dynamic url
  {
    path: 'greeting/:message', component: MessageComponent
  },

ActivatedRoute: 
 It is object to read url information into component  like params,query params
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-message',
  templateUrl: './message.component.html',
  styles: [
  ]
})
export class MessageComponent implements OnInit {

  message: string = ""
  //to read url information: params,queryParams
  constructor(private routerInfo: ActivatedRoute) { }

  ngOnInit(): void {
    this.routerInfo.params.subscribe(info => {
      console.log(info);
      this.message = info.message
    });
  }

}
<div>
    <h1>{{message}}</h1>
</div>
.............................................................................................
///////////////////////////////////////////////////////////////////////////////////////////

                                 Nested Routing
///////////////////////////////////////////////////////////////////////////////////////////

Nesting routes

  {
    path: 'greeter', component: GreeterComponent,
    children: [
      {
       path:'',redirectTo:'/greeter/hai' , pathMatch:'full'
      },
      {
        path: 'hai', component: HaiComponent,
      },
      {
        path: 'hello', component: HelloComponent,
      },
    ]
  }

<nav>
    <a routerLink="./hello">Hello</a> | 
    <a routerLink="./hai">Hai</a>
</nav>
<router-outlet></router-outlet>
.............................................................................................
				Routing via code : Programmetic routing
.............................................................................................

import { Component } from '@angular/core';
import { Router } from '@angular/router';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'routingapp';
  constructor(private router:Router){
  }
  public goToGreeter(){
   this.router.navigate(['greeter'])
  }
}
<button (click)="goToGreeter()">GoToGreeter</button>
.............................................................................................
			Modularization and Routing, Lazyloading.
.............................................................................................
				Forms
............................................................................................
/////////////////////////////////////////////////////////////////////////////////////////////
				 Forms
////////////////////////////////////////////////////////////////////////////////////////////

Forms are used to get input from the User.

Types of Forms

1.Template driven Forms
2.Reactive forms


Tempate Driven Forms:
...................

Steps:

1.FormsModule

import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

2.declare FormModel Object going to hold form field data

export class PostFormModel{
    constructor(public id: number, public title: string, public author: string){
    }
}

3.Create Model Object inside component.

export class AppComponent {
  post: any;
  constructor() {
    this.post = new PostFormModel(Math.random(), 'Learn Angular', 'Misko')
  }
}

Step 4 : 
Create inital form Template
 -Forms should have bootstrap style

<div class="container">
  <h1>Post Form</h1>
  <form>
    <div class="form-group">
      <label for="title">Title</label>
      <input type="text" class="form-control" id="title" required>
    </div>

    <div class="form-group">
      <label for="name">Name</label>
      <input type="text" class="form-control" id="name" required>
    </div>

    <button type="submit" class="btn btn-success">Submit</button>

  </form>
</div>


Step 5:

Data binding
   Binding textbox(form controls) with Model Object
   We have many ways
  1.through instance variable,$event
  2.through [(ngModel)]="post.title"
   ngModel = > it is an object from "FormsModule"
   ngModel it is dto object=>data transfering between view and component.

//
Form Control value property is bound with name property of input control.

<input [(ngModel)]="post.title" name="title" type="text" class="form-control" id="title" required>

    <form>
       <!--TODO: Remove this once testing over-->
       <pre>{{post | json}}</pre>
      <div class="form-group">
         <label for="title">Title</label>
         <input [(ngModel)]="post.title" name="title" type="text" class="form-control" id="title" required>
       </div>
       <div class="form-group">
         <label for="name">Name</label>
         <input [(ngModel)]="post.author" name="author" type="text" class="form-control" id="name" required>
       </div>
   
       <button type="submit" class="btn btn-success">Submit</button>
    </form>

*****************************************************************************************
					Vaildation
///////////////////////////////////////////////////////////////////////////////////////////

Objects In the FormsModule:

NgForm : 

 It is object representation of "form" element.
 Can be used to control form validations.
 in order to access the NgForm object inside template. You have to use template reference

<form #postForm> =>postForm points HTMLForm Object

ngForm is Object which inherits HTMLForm

class ngForm extends HTMLForm{
  +extra behavior=>Ready made validation code
  +form submission behviours
}

What is meaning of this code <form #postForm>?

 HTMLFORMMobject ----postPorm

dummy code for the above template
 let postForm =  new HTMLForm();

what we need
 let postForm = new NgForm()

<form #postForm="ngForm"> 


The variable postForm is now a reference to the NgForm 
directive that governs the form as a whole.

The NgForm directive:

What NgForm directive? You didn't add an NgForm directive before.

Angular did. Angular automatically creates and attaches
 an NgForm directive to the <form> tag.

"The NgForm directive supplements the form element with additional features. 

It holds the controls you created for the elements  with an "ngModel directive" and name attribute, and monitors their properties, including their validity.
 
It also has its own valid property which is true only if every contained control is valid."

Note: NgForm is built Object ,has more logic for simlifying our form handling process.

********************************************************************************************
********************************************************************************************
NgModel :

 1.Transfering data between UI and Controller .

NgModel not only for data transfer, which does so many other things beyond twoway data binding.

Track control(form element) state and validity with ngModel:
............................................................

Form element states:

Angular provides built-in css classes to tract form control state"

State 	                         Class if true 	  Class if false

The control has been visited.  	  ng-touched 	    ng-untouched
The control's value has changed.  ng-dirty 	    ng-pristine
The control's value is valid. 	  ng-valid 	    ng-invalid

State Tracking Steps:

1.Look but don't touch.
2.Click inside the name box, then click outside it.
3.Add slashes to the end of the name.
4.Erase the name.

ng-untouched - if you dont touch
ng-touched - if you touch
ng-dirty - if you changed
ng-invalid - if you remove all-empty field

Step 6:

Add custom CSS for visual feedback:

Valid + Required - green Color
Valid + optional - white color
Invalid (required | optional) - red Color

Angular Css:

.ng-valid[required], .ng-valid.required  {
  border-left: 5px solid #42A948; /* green */
}

.ng-invalid:not(form)  {
  border-left: 5px solid #a94442; /* red */
}

****************************************************************************************

Adding validation block to our code:
...................................

NgModel is Child Object of FormControl Object

class  Input{
 
}
class NgModel extends Input{
  //extra features : state tracking,enabling validation.
}

<input #Xx> -Here xxPoints only Input

<input #Xx="ngModel"> -Here xx points ngModel

      <input  [(ngModel)]="post.title" #errorMsg1="ngModel" name="title" type="text" class="form-control" id="title" required>

Step 7: Add Error Block
<div class="container">
  <h1>Post Form</h1>
  <form #postForm="ngForm">
    <!--TODO: Remove this once testing over-->
    <pre>{{post | json}}</pre>
    <div class="form-group">
      <label for="title">Title</label>
      <input [(ngModel)]="post.title" #errorMsg1="ngModel" name="title" type="text" class="form-control" id="title"
        required>
      <div [hidden]="errorMsg1.valid || errorMsg1.pristine" class="alert alert-danger">
        title is required
      </div>
    </div>

    <div class="form-group">
      <label for="name">Name</label>
      <input [(ngModel)]="post.author" #errorMsg2="ngModel" name="author" type="text" class="form-control" id="name"
        required>
      <div [hidden]="errorMsg2.valid || errorMsg2.pristine" class="alert alert-danger">
        Author is required
      </div>
    </div>
    <button type="submit" class="btn btn-success">Submit</button>

  </form>
</div>

Step 7: Disabling submit button until the whole form is valid.
*******************************************************************************************

Disabling submit button in case any validation fails:

  <button type="submit" class="btn btn-success" [disabled]="!postForm.form.valid">Submit</button>

*******************************************************************************************


Step 8:Adding combo box: Select Control


export class PostFormModel {
    constructor(public id: number, public title: string, public author: string, public category: string) {
    }
}
export class AppComponent {
  post: any;
  //you may get  this from services
  categories: Array<string> = ["User interface", "MicroServices", "Devops"];
  constructor() {
    this.post = new PostFormModel(Math.random(), 'Learn Angular', 'Misko', this.categories[0])
  }
}

    <div class="form-group">
      <label for="category">Category</label>
      <select class="form-control" id="category" name="category" 
       [(ngModel)]="post.category">
        <option *ngFor="let cat of categories"  [value]="cat">
          {{cat}}
        </option>
      </select>
    </div>
////////////////////////////////////////////////////////////////////////////////////////////

Step 9: How to submit Form? and show another page

Add listener in the form tag.
 <form #postForm="ngForm" (ngSubmit)="onSubmit()">


<div class="container">
  <h1>Post Form</h1>
  <div [hidden]="submitted">
    <form #postForm="ngForm" (ngSubmit)="onSubmit()">
      <!--TODO: Remove this once testing over-->
      <pre>{{post | json}}</pre>
      <div class="form-group">
        <label for="title">Title</label>
        <input [(ngModel)]="post.title" #errorMsg1="ngModel" name="title" type="text" class="form-control" id="title"
          required>
        <div [hidden]="errorMsg1.valid || errorMsg1.pristine" class="alert alert-danger">
          title is required
        </div>
      </div>

      <div class="form-group">
        <label for="name">Name</label>
        <input [(ngModel)]="post.author" #errorMsg2="ngModel" name="author" type="text" class="form-control" id="name"
          required>
        <div [hidden]="errorMsg2.valid || errorMsg2.pristine" class="alert alert-danger">
          Author is required
        </div>
      </div>

      <div class="form-group">
        <label for="category">Category</label>
        <select class="form-control" id="category" name="category" [(ngModel)]="post.category">
          <option *ngFor="let cat of categories" [value]="cat">
            {{cat}}
          </option>
        </select>
      </div>


      <button type="submit" class="btn btn-success" [disabled]="!postForm.form.valid">Submit</button>
    </form>
  </div>

  <!--Details Page-->
  <div class="container" [hidden]="!submitted">
    <h2>You submitted the following:</h2>
    <div class="row">
      <div class="col-xs-3">Id : </div>
      <div class="col-xs-9  pull-left">{{ post.id }}</div>
    </div>
    <div class="row">
      <div class="col-xs-3">Title : </div>
      <div class="col-xs-9  pull-left">{{ post.title }}</div>
    </div>
    <div class="row">
      <div class="col-xs-3">Author : </div>
      <div class="col-xs-9 pull-left">{{ post.author }}</div>
    </div>
    <div class="row">
      <div class="col-xs-3">Category : </div>
      <div class="col-xs-9 pull-left">{{ post.category }}</div>
    </div>
    <br>
    <button class="btn btn-primary" (click)="submitted=false">GoBack</button>
  </div>

</div>

import { Component } from '@angular/core';
import { PostFormModel } from './post.form.model';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  post: any;
  submitted: boolean = false;
  //you may get  this from services
  categories: Array<string> = ["User interface", "MicroServices", "Devops"];
  constructor() {
    this.post = new PostFormModel(Math.random(), 'Learn Angular', 'Misko', this.categories[0])
  }
  onSubmit(){
     alert(JSON.stringify(this.post))
     this.submitted = true;
  }
}


export class PostFormModel {
    constructor(public id: number, public title: string, public author: string, public category: string) {
    }
}
.............................................................................................
